package dhcp6

import "net"

// RelayMessage represents a raw RelayMessage generated by DHCPv6 relay agent, using RFC 3315,
// Section 7.
type RelayMessage struct {
	// RELAY-FORW or RELAY-REPL only
	MessageType MessageType

	// Number of relay agents that have relayed this
	// message.
	HopCount uint8

	// A global or site-local address that will be used by
	// the server to identify the link on which the client
	// is located.
	LinkAddress net.IP

	// The address of the client or relay agent from which
	// the message to be relayed was received.
	PeerAddress net.IP

	// Options specifies a map of DHCP options.  Its methods can be used to
	// retrieve data from an incoming RelayMessage, or send data with an outgoing
	// RelayMessage.
	// MUST include a "Relay Message option" (see
	// section 22.10); MAY include other options added by
	// the relay agent.
	Options Options
}

// MarshalBinary allocates a byte slice containing the data
// from a RelayMessage.
func (p *RelayMessage) MarshalBinary() ([]byte, error) {
	// 1 byte: message type
	// 1 byte: hop-count
	// 16 bytes: link-address
	// 16 bytes: peer-address
	// N bytes: options slice byte count

	opts := p.Options.enumerate()
	b := make([]byte, 34+opts.count())

	b[0] = byte(p.MessageType)
	b[1] = byte(p.HopCount)
	copy(b[2:2+net.IPv6len], p.LinkAddress[:])
	copy(b[18:18+net.IPv6len], p.PeerAddress[:])
	opts.write(b[34:])

	return b, nil
}

// UnmarshalBinary unmarshals a raw byte slice into a RelayMessage.
//
// If the byte slice does not contain enough data to form a valid RelayMessage,
// ErrInvalidPacket is returned.
func (p *RelayMessage) UnmarshalBinary(b []byte) error {
	// RelayMessage must contain at least message type, hop-count, link-address and peer-address
	if len(b) < 34 {
		return ErrInvalidPacket
	}

	p.MessageType = MessageType(b[0])
	p.HopCount = uint8(b[1])

	link := [net.IPv6len]byte{}
	copy(link[:], b[2:2+net.IPv6len])
	p.LinkAddress = net.IP(link[:])

	peer := [net.IPv6len]byte{}
	copy(peer[:], b[18:18+net.IPv6len])
	p.PeerAddress = net.IP(peer[:])

	options, err := parseOptions(b[34:])
	if err != nil {
		// Invalid options means an invalid RelayMessage
		return ErrInvalidPacket
	}
	p.Options = options

	return nil
}
